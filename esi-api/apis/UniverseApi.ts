/* tslint:disable */
/* eslint-disable */
/**
 * EVE Swagger Interface
 * An OpenAPI for EVE Online
 *
 * The version of the OpenAPI document: 1.7.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    BadRequest,
    BadRequestFromJSON,
    BadRequestToJSON,
    ErrorLimited,
    ErrorLimitedFromJSON,
    ErrorLimitedToJSON,
    Forbidden,
    ForbiddenFromJSON,
    ForbiddenToJSON,
    GatewayTimeout,
    GatewayTimeoutFromJSON,
    GatewayTimeoutToJSON,
    GetUniverseAncestries200Ok,
    GetUniverseAncestries200OkFromJSON,
    GetUniverseAncestries200OkToJSON,
    GetUniverseAsteroidBeltsAsteroidBeltIdNotFound,
    GetUniverseAsteroidBeltsAsteroidBeltIdNotFoundFromJSON,
    GetUniverseAsteroidBeltsAsteroidBeltIdNotFoundToJSON,
    GetUniverseAsteroidBeltsAsteroidBeltIdOk,
    GetUniverseAsteroidBeltsAsteroidBeltIdOkFromJSON,
    GetUniverseAsteroidBeltsAsteroidBeltIdOkToJSON,
    GetUniverseBloodlines200Ok,
    GetUniverseBloodlines200OkFromJSON,
    GetUniverseBloodlines200OkToJSON,
    GetUniverseCategoriesCategoryIdNotFound,
    GetUniverseCategoriesCategoryIdNotFoundFromJSON,
    GetUniverseCategoriesCategoryIdNotFoundToJSON,
    GetUniverseCategoriesCategoryIdOk,
    GetUniverseCategoriesCategoryIdOkFromJSON,
    GetUniverseCategoriesCategoryIdOkToJSON,
    GetUniverseConstellationsConstellationIdNotFound,
    GetUniverseConstellationsConstellationIdNotFoundFromJSON,
    GetUniverseConstellationsConstellationIdNotFoundToJSON,
    GetUniverseConstellationsConstellationIdOk,
    GetUniverseConstellationsConstellationIdOkFromJSON,
    GetUniverseConstellationsConstellationIdOkToJSON,
    GetUniverseFactions200Ok,
    GetUniverseFactions200OkFromJSON,
    GetUniverseFactions200OkToJSON,
    GetUniverseGraphicsGraphicIdNotFound,
    GetUniverseGraphicsGraphicIdNotFoundFromJSON,
    GetUniverseGraphicsGraphicIdNotFoundToJSON,
    GetUniverseGraphicsGraphicIdOk,
    GetUniverseGraphicsGraphicIdOkFromJSON,
    GetUniverseGraphicsGraphicIdOkToJSON,
    GetUniverseGroupsGroupIdNotFound,
    GetUniverseGroupsGroupIdNotFoundFromJSON,
    GetUniverseGroupsGroupIdNotFoundToJSON,
    GetUniverseGroupsGroupIdOk,
    GetUniverseGroupsGroupIdOkFromJSON,
    GetUniverseGroupsGroupIdOkToJSON,
    GetUniverseMoonsMoonIdNotFound,
    GetUniverseMoonsMoonIdNotFoundFromJSON,
    GetUniverseMoonsMoonIdNotFoundToJSON,
    GetUniverseMoonsMoonIdOk,
    GetUniverseMoonsMoonIdOkFromJSON,
    GetUniverseMoonsMoonIdOkToJSON,
    GetUniversePlanetsPlanetIdNotFound,
    GetUniversePlanetsPlanetIdNotFoundFromJSON,
    GetUniversePlanetsPlanetIdNotFoundToJSON,
    GetUniversePlanetsPlanetIdOk,
    GetUniversePlanetsPlanetIdOkFromJSON,
    GetUniversePlanetsPlanetIdOkToJSON,
    GetUniverseRaces200Ok,
    GetUniverseRaces200OkFromJSON,
    GetUniverseRaces200OkToJSON,
    GetUniverseRegionsRegionIdNotFound,
    GetUniverseRegionsRegionIdNotFoundFromJSON,
    GetUniverseRegionsRegionIdNotFoundToJSON,
    GetUniverseRegionsRegionIdOk,
    GetUniverseRegionsRegionIdOkFromJSON,
    GetUniverseRegionsRegionIdOkToJSON,
    GetUniverseStargatesStargateIdNotFound,
    GetUniverseStargatesStargateIdNotFoundFromJSON,
    GetUniverseStargatesStargateIdNotFoundToJSON,
    GetUniverseStargatesStargateIdOk,
    GetUniverseStargatesStargateIdOkFromJSON,
    GetUniverseStargatesStargateIdOkToJSON,
    GetUniverseStarsStarIdOk,
    GetUniverseStarsStarIdOkFromJSON,
    GetUniverseStarsStarIdOkToJSON,
    GetUniverseStationsStationIdNotFound,
    GetUniverseStationsStationIdNotFoundFromJSON,
    GetUniverseStationsStationIdNotFoundToJSON,
    GetUniverseStationsStationIdOk,
    GetUniverseStationsStationIdOkFromJSON,
    GetUniverseStationsStationIdOkToJSON,
    GetUniverseStructuresStructureIdNotFound,
    GetUniverseStructuresStructureIdNotFoundFromJSON,
    GetUniverseStructuresStructureIdNotFoundToJSON,
    GetUniverseStructuresStructureIdOk,
    GetUniverseStructuresStructureIdOkFromJSON,
    GetUniverseStructuresStructureIdOkToJSON,
    GetUniverseSystemJumps200Ok,
    GetUniverseSystemJumps200OkFromJSON,
    GetUniverseSystemJumps200OkToJSON,
    GetUniverseSystemKills200Ok,
    GetUniverseSystemKills200OkFromJSON,
    GetUniverseSystemKills200OkToJSON,
    GetUniverseSystemsSystemIdNotFound,
    GetUniverseSystemsSystemIdNotFoundFromJSON,
    GetUniverseSystemsSystemIdNotFoundToJSON,
    GetUniverseSystemsSystemIdOk,
    GetUniverseSystemsSystemIdOkFromJSON,
    GetUniverseSystemsSystemIdOkToJSON,
    GetUniverseTypesTypeIdNotFound,
    GetUniverseTypesTypeIdNotFoundFromJSON,
    GetUniverseTypesTypeIdNotFoundToJSON,
    GetUniverseTypesTypeIdOk,
    GetUniverseTypesTypeIdOkFromJSON,
    GetUniverseTypesTypeIdOkToJSON,
    InternalServerError,
    InternalServerErrorFromJSON,
    InternalServerErrorToJSON,
    PostUniverseIdsOk,
    PostUniverseIdsOkFromJSON,
    PostUniverseIdsOkToJSON,
    PostUniverseNames200Ok,
    PostUniverseNames200OkFromJSON,
    PostUniverseNames200OkToJSON,
    PostUniverseNamesNotFound,
    PostUniverseNamesNotFoundFromJSON,
    PostUniverseNamesNotFoundToJSON,
    ServiceUnavailable,
    ServiceUnavailableFromJSON,
    ServiceUnavailableToJSON,
    Unauthorized,
    UnauthorizedFromJSON,
    UnauthorizedToJSON,
} from '../models';

export interface GetUniverseAncestriesRequest {
    acceptLanguage?: GetUniverseAncestriesAcceptLanguageEnum;
    datasource?: GetUniverseAncestriesDatasourceEnum;
    ifNoneMatch?: string;
    language?: GetUniverseAncestriesLanguageEnum;
}

export interface GetUniverseAsteroidBeltsAsteroidBeltIdRequest {
    asteroidBeltId: number;
    datasource?: GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseBloodlinesRequest {
    acceptLanguage?: GetUniverseBloodlinesAcceptLanguageEnum;
    datasource?: GetUniverseBloodlinesDatasourceEnum;
    ifNoneMatch?: string;
    language?: GetUniverseBloodlinesLanguageEnum;
}

export interface GetUniverseCategoriesRequest {
    datasource?: GetUniverseCategoriesDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseCategoriesCategoryIdRequest {
    categoryId: number;
    acceptLanguage?: GetUniverseCategoriesCategoryIdAcceptLanguageEnum;
    datasource?: GetUniverseCategoriesCategoryIdDatasourceEnum;
    ifNoneMatch?: string;
    language?: GetUniverseCategoriesCategoryIdLanguageEnum;
}

export interface GetUniverseConstellationsRequest {
    datasource?: GetUniverseConstellationsDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseConstellationsConstellationIdRequest {
    constellationId: number;
    acceptLanguage?: GetUniverseConstellationsConstellationIdAcceptLanguageEnum;
    datasource?: GetUniverseConstellationsConstellationIdDatasourceEnum;
    ifNoneMatch?: string;
    language?: GetUniverseConstellationsConstellationIdLanguageEnum;
}

export interface GetUniverseFactionsRequest {
    acceptLanguage?: GetUniverseFactionsAcceptLanguageEnum;
    datasource?: GetUniverseFactionsDatasourceEnum;
    ifNoneMatch?: string;
    language?: GetUniverseFactionsLanguageEnum;
}

export interface GetUniverseGraphicsRequest {
    datasource?: GetUniverseGraphicsDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseGraphicsGraphicIdRequest {
    graphicId: number;
    datasource?: GetUniverseGraphicsGraphicIdDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseGroupsRequest {
    datasource?: GetUniverseGroupsDatasourceEnum;
    ifNoneMatch?: string;
    page?: number;
}

export interface GetUniverseGroupsGroupIdRequest {
    groupId: number;
    acceptLanguage?: GetUniverseGroupsGroupIdAcceptLanguageEnum;
    datasource?: GetUniverseGroupsGroupIdDatasourceEnum;
    ifNoneMatch?: string;
    language?: GetUniverseGroupsGroupIdLanguageEnum;
}

export interface GetUniverseMoonsMoonIdRequest {
    moonId: number;
    datasource?: GetUniverseMoonsMoonIdDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniversePlanetsPlanetIdRequest {
    planetId: number;
    datasource?: GetUniversePlanetsPlanetIdDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseRacesRequest {
    acceptLanguage?: GetUniverseRacesAcceptLanguageEnum;
    datasource?: GetUniverseRacesDatasourceEnum;
    ifNoneMatch?: string;
    language?: GetUniverseRacesLanguageEnum;
}

export interface GetUniverseRegionsRequest {
    datasource?: GetUniverseRegionsDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseRegionsRegionIdRequest {
    regionId: number;
    acceptLanguage?: GetUniverseRegionsRegionIdAcceptLanguageEnum;
    datasource?: GetUniverseRegionsRegionIdDatasourceEnum;
    ifNoneMatch?: string;
    language?: GetUniverseRegionsRegionIdLanguageEnum;
}

export interface GetUniverseStargatesStargateIdRequest {
    stargateId: number;
    datasource?: GetUniverseStargatesStargateIdDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseStarsStarIdRequest {
    starId: number;
    datasource?: GetUniverseStarsStarIdDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseStationsStationIdRequest {
    stationId: number;
    datasource?: GetUniverseStationsStationIdDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseStructuresRequest {
    datasource?: GetUniverseStructuresDatasourceEnum;
    filter?: GetUniverseStructuresFilterEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseStructuresStructureIdRequest {
    structureId: number;
    datasource?: GetUniverseStructuresStructureIdDatasourceEnum;
    ifNoneMatch?: string;
    token?: string;
}

export interface GetUniverseSystemJumpsRequest {
    datasource?: GetUniverseSystemJumpsDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseSystemKillsRequest {
    datasource?: GetUniverseSystemKillsDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseSystemsRequest {
    datasource?: GetUniverseSystemsDatasourceEnum;
    ifNoneMatch?: string;
}

export interface GetUniverseSystemsSystemIdRequest {
    systemId: number;
    acceptLanguage?: GetUniverseSystemsSystemIdAcceptLanguageEnum;
    datasource?: GetUniverseSystemsSystemIdDatasourceEnum;
    ifNoneMatch?: string;
    language?: GetUniverseSystemsSystemIdLanguageEnum;
}

export interface GetUniverseTypesRequest {
    datasource?: GetUniverseTypesDatasourceEnum;
    ifNoneMatch?: string;
    page?: number;
}

export interface GetUniverseTypesTypeIdRequest {
    typeId: number;
    acceptLanguage?: GetUniverseTypesTypeIdAcceptLanguageEnum;
    datasource?: GetUniverseTypesTypeIdDatasourceEnum;
    ifNoneMatch?: string;
    language?: GetUniverseTypesTypeIdLanguageEnum;
}

export interface PostUniverseIdsRequest {
    names: Array<string>;
    acceptLanguage?: PostUniverseIdsAcceptLanguageEnum;
    datasource?: PostUniverseIdsDatasourceEnum;
    language?: PostUniverseIdsLanguageEnum;
}

export interface PostUniverseNamesRequest {
    ids: Array<number>;
    datasource?: PostUniverseNamesDatasourceEnum;
}

/**
 * 
 */
export class UniverseApi extends runtime.BaseAPI {

    /**
     * Get all character ancestries  --- Alternate route: `/dev/universe/ancestries/`  Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
     * Get ancestries
     */
    async getUniverseAncestriesRaw(requestParameters: GetUniverseAncestriesRequest): Promise<runtime.ApiResponse<Array<GetUniverseAncestries200Ok>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/ancestries/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GetUniverseAncestries200OkFromJSON));
    }

    /**
     * Get all character ancestries  --- Alternate route: `/dev/universe/ancestries/`  Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
     * Get ancestries
     */
    async getUniverseAncestries(requestParameters: GetUniverseAncestriesRequest): Promise<Array<GetUniverseAncestries200Ok>> {
        const response = await this.getUniverseAncestriesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information on an asteroid belt  --- Alternate route: `/dev/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
     * Get asteroid belt information
     */
    async getUniverseAsteroidBeltsAsteroidBeltIdRaw(requestParameters: GetUniverseAsteroidBeltsAsteroidBeltIdRequest): Promise<runtime.ApiResponse<GetUniverseAsteroidBeltsAsteroidBeltIdOk>> {
        if (requestParameters.asteroidBeltId === null || requestParameters.asteroidBeltId === undefined) {
            throw new runtime.RequiredError('asteroidBeltId','Required parameter requestParameters.asteroidBeltId was null or undefined when calling getUniverseAsteroidBeltsAsteroidBeltId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/asteroid_belts/{asteroid_belt_id}/`.replace(`{${"asteroid_belt_id"}}`, encodeURIComponent(String(requestParameters.asteroidBeltId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseAsteroidBeltsAsteroidBeltIdOkFromJSON(jsonValue));
    }

    /**
     * Get information on an asteroid belt  --- Alternate route: `/dev/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
     * Get asteroid belt information
     */
    async getUniverseAsteroidBeltsAsteroidBeltId(requestParameters: GetUniverseAsteroidBeltsAsteroidBeltIdRequest): Promise<GetUniverseAsteroidBeltsAsteroidBeltIdOk> {
        const response = await this.getUniverseAsteroidBeltsAsteroidBeltIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a list of bloodlines  --- Alternate route: `/dev/universe/bloodlines/`  Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
     * Get bloodlines
     */
    async getUniverseBloodlinesRaw(requestParameters: GetUniverseBloodlinesRequest): Promise<runtime.ApiResponse<Array<GetUniverseBloodlines200Ok>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/bloodlines/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GetUniverseBloodlines200OkFromJSON));
    }

    /**
     * Get a list of bloodlines  --- Alternate route: `/dev/universe/bloodlines/`  Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
     * Get bloodlines
     */
    async getUniverseBloodlines(requestParameters: GetUniverseBloodlinesRequest): Promise<Array<GetUniverseBloodlines200Ok>> {
        const response = await this.getUniverseBloodlinesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a list of item categories  --- Alternate route: `/dev/universe/categories/`  Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
     * Get item categories
     */
    async getUniverseCategoriesRaw(requestParameters: GetUniverseCategoriesRequest): Promise<runtime.ApiResponse<Array<number>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/categories/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of item categories  --- Alternate route: `/dev/universe/categories/`  Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
     * Get item categories
     */
    async getUniverseCategories(requestParameters: GetUniverseCategoriesRequest): Promise<Array<number>> {
        const response = await this.getUniverseCategoriesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information of an item category  --- Alternate route: `/dev/universe/categories/{category_id}/`  Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
     * Get item category information
     */
    async getUniverseCategoriesCategoryIdRaw(requestParameters: GetUniverseCategoriesCategoryIdRequest): Promise<runtime.ApiResponse<GetUniverseCategoriesCategoryIdOk>> {
        if (requestParameters.categoryId === null || requestParameters.categoryId === undefined) {
            throw new runtime.RequiredError('categoryId','Required parameter requestParameters.categoryId was null or undefined when calling getUniverseCategoriesCategoryId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/categories/{category_id}/`.replace(`{${"category_id"}}`, encodeURIComponent(String(requestParameters.categoryId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseCategoriesCategoryIdOkFromJSON(jsonValue));
    }

    /**
     * Get information of an item category  --- Alternate route: `/dev/universe/categories/{category_id}/`  Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
     * Get item category information
     */
    async getUniverseCategoriesCategoryId(requestParameters: GetUniverseCategoriesCategoryIdRequest): Promise<GetUniverseCategoriesCategoryIdOk> {
        const response = await this.getUniverseCategoriesCategoryIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a list of constellations  --- Alternate route: `/dev/universe/constellations/`  Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
     * Get constellations
     */
    async getUniverseConstellationsRaw(requestParameters: GetUniverseConstellationsRequest): Promise<runtime.ApiResponse<Array<number>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/constellations/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of constellations  --- Alternate route: `/dev/universe/constellations/`  Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
     * Get constellations
     */
    async getUniverseConstellations(requestParameters: GetUniverseConstellationsRequest): Promise<Array<number>> {
        const response = await this.getUniverseConstellationsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information on a constellation  --- Alternate route: `/dev/universe/constellations/{constellation_id}/`  Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
     * Get constellation information
     */
    async getUniverseConstellationsConstellationIdRaw(requestParameters: GetUniverseConstellationsConstellationIdRequest): Promise<runtime.ApiResponse<GetUniverseConstellationsConstellationIdOk>> {
        if (requestParameters.constellationId === null || requestParameters.constellationId === undefined) {
            throw new runtime.RequiredError('constellationId','Required parameter requestParameters.constellationId was null or undefined when calling getUniverseConstellationsConstellationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/constellations/{constellation_id}/`.replace(`{${"constellation_id"}}`, encodeURIComponent(String(requestParameters.constellationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseConstellationsConstellationIdOkFromJSON(jsonValue));
    }

    /**
     * Get information on a constellation  --- Alternate route: `/dev/universe/constellations/{constellation_id}/`  Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
     * Get constellation information
     */
    async getUniverseConstellationsConstellationId(requestParameters: GetUniverseConstellationsConstellationIdRequest): Promise<GetUniverseConstellationsConstellationIdOk> {
        const response = await this.getUniverseConstellationsConstellationIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
     * Get factions
     */
    async getUniverseFactionsRaw(requestParameters: GetUniverseFactionsRequest): Promise<runtime.ApiResponse<Array<GetUniverseFactions200Ok>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/factions/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GetUniverseFactions200OkFromJSON));
    }

    /**
     * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
     * Get factions
     */
    async getUniverseFactions(requestParameters: GetUniverseFactionsRequest): Promise<Array<GetUniverseFactions200Ok>> {
        const response = await this.getUniverseFactionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a list of graphics  --- Alternate route: `/dev/universe/graphics/`  Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
     * Get graphics
     */
    async getUniverseGraphicsRaw(requestParameters: GetUniverseGraphicsRequest): Promise<runtime.ApiResponse<Array<number>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/graphics/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of graphics  --- Alternate route: `/dev/universe/graphics/`  Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
     * Get graphics
     */
    async getUniverseGraphics(requestParameters: GetUniverseGraphicsRequest): Promise<Array<number>> {
        const response = await this.getUniverseGraphicsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
     * Get graphic information
     */
    async getUniverseGraphicsGraphicIdRaw(requestParameters: GetUniverseGraphicsGraphicIdRequest): Promise<runtime.ApiResponse<GetUniverseGraphicsGraphicIdOk>> {
        if (requestParameters.graphicId === null || requestParameters.graphicId === undefined) {
            throw new runtime.RequiredError('graphicId','Required parameter requestParameters.graphicId was null or undefined when calling getUniverseGraphicsGraphicId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/graphics/{graphic_id}/`.replace(`{${"graphic_id"}}`, encodeURIComponent(String(requestParameters.graphicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseGraphicsGraphicIdOkFromJSON(jsonValue));
    }

    /**
     * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
     * Get graphic information
     */
    async getUniverseGraphicsGraphicId(requestParameters: GetUniverseGraphicsGraphicIdRequest): Promise<GetUniverseGraphicsGraphicIdOk> {
        const response = await this.getUniverseGraphicsGraphicIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a list of item groups  --- Alternate route: `/dev/universe/groups/`  Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
     * Get item groups
     */
    async getUniverseGroupsRaw(requestParameters: GetUniverseGroupsRequest): Promise<runtime.ApiResponse<Array<number>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/groups/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of item groups  --- Alternate route: `/dev/universe/groups/`  Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
     * Get item groups
     */
    async getUniverseGroups(requestParameters: GetUniverseGroupsRequest): Promise<Array<number>> {
        const response = await this.getUniverseGroupsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
     * Get item group information
     */
    async getUniverseGroupsGroupIdRaw(requestParameters: GetUniverseGroupsGroupIdRequest): Promise<runtime.ApiResponse<GetUniverseGroupsGroupIdOk>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling getUniverseGroupsGroupId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/groups/{group_id}/`.replace(`{${"group_id"}}`, encodeURIComponent(String(requestParameters.groupId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseGroupsGroupIdOkFromJSON(jsonValue));
    }

    /**
     * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
     * Get item group information
     */
    async getUniverseGroupsGroupId(requestParameters: GetUniverseGroupsGroupIdRequest): Promise<GetUniverseGroupsGroupIdOk> {
        const response = await this.getUniverseGroupsGroupIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information on a moon  --- Alternate route: `/dev/universe/moons/{moon_id}/`  Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
     * Get moon information
     */
    async getUniverseMoonsMoonIdRaw(requestParameters: GetUniverseMoonsMoonIdRequest): Promise<runtime.ApiResponse<GetUniverseMoonsMoonIdOk>> {
        if (requestParameters.moonId === null || requestParameters.moonId === undefined) {
            throw new runtime.RequiredError('moonId','Required parameter requestParameters.moonId was null or undefined when calling getUniverseMoonsMoonId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/moons/{moon_id}/`.replace(`{${"moon_id"}}`, encodeURIComponent(String(requestParameters.moonId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseMoonsMoonIdOkFromJSON(jsonValue));
    }

    /**
     * Get information on a moon  --- Alternate route: `/dev/universe/moons/{moon_id}/`  Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
     * Get moon information
     */
    async getUniverseMoonsMoonId(requestParameters: GetUniverseMoonsMoonIdRequest): Promise<GetUniverseMoonsMoonIdOk> {
        const response = await this.getUniverseMoonsMoonIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information on a planet  --- Alternate route: `/dev/universe/planets/{planet_id}/`  Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
     * Get planet information
     */
    async getUniversePlanetsPlanetIdRaw(requestParameters: GetUniversePlanetsPlanetIdRequest): Promise<runtime.ApiResponse<GetUniversePlanetsPlanetIdOk>> {
        if (requestParameters.planetId === null || requestParameters.planetId === undefined) {
            throw new runtime.RequiredError('planetId','Required parameter requestParameters.planetId was null or undefined when calling getUniversePlanetsPlanetId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/planets/{planet_id}/`.replace(`{${"planet_id"}}`, encodeURIComponent(String(requestParameters.planetId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniversePlanetsPlanetIdOkFromJSON(jsonValue));
    }

    /**
     * Get information on a planet  --- Alternate route: `/dev/universe/planets/{planet_id}/`  Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
     * Get planet information
     */
    async getUniversePlanetsPlanetId(requestParameters: GetUniversePlanetsPlanetIdRequest): Promise<GetUniversePlanetsPlanetIdOk> {
        const response = await this.getUniversePlanetsPlanetIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
     * Get character races
     */
    async getUniverseRacesRaw(requestParameters: GetUniverseRacesRequest): Promise<runtime.ApiResponse<Array<GetUniverseRaces200Ok>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/races/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GetUniverseRaces200OkFromJSON));
    }

    /**
     * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
     * Get character races
     */
    async getUniverseRaces(requestParameters: GetUniverseRacesRequest): Promise<Array<GetUniverseRaces200Ok>> {
        const response = await this.getUniverseRacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a list of regions  --- Alternate route: `/dev/universe/regions/`  Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
     * Get regions
     */
    async getUniverseRegionsRaw(requestParameters: GetUniverseRegionsRequest): Promise<runtime.ApiResponse<Array<number>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/regions/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of regions  --- Alternate route: `/dev/universe/regions/`  Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
     * Get regions
     */
    async getUniverseRegions(requestParameters: GetUniverseRegionsRequest): Promise<Array<number>> {
        const response = await this.getUniverseRegionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information on a region  --- Alternate route: `/dev/universe/regions/{region_id}/`  Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
     * Get region information
     */
    async getUniverseRegionsRegionIdRaw(requestParameters: GetUniverseRegionsRegionIdRequest): Promise<runtime.ApiResponse<GetUniverseRegionsRegionIdOk>> {
        if (requestParameters.regionId === null || requestParameters.regionId === undefined) {
            throw new runtime.RequiredError('regionId','Required parameter requestParameters.regionId was null or undefined when calling getUniverseRegionsRegionId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/regions/{region_id}/`.replace(`{${"region_id"}}`, encodeURIComponent(String(requestParameters.regionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseRegionsRegionIdOkFromJSON(jsonValue));
    }

    /**
     * Get information on a region  --- Alternate route: `/dev/universe/regions/{region_id}/`  Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
     * Get region information
     */
    async getUniverseRegionsRegionId(requestParameters: GetUniverseRegionsRegionIdRequest): Promise<GetUniverseRegionsRegionIdOk> {
        const response = await this.getUniverseRegionsRegionIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information on a stargate  --- Alternate route: `/dev/universe/stargates/{stargate_id}/`  Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
     * Get stargate information
     */
    async getUniverseStargatesStargateIdRaw(requestParameters: GetUniverseStargatesStargateIdRequest): Promise<runtime.ApiResponse<GetUniverseStargatesStargateIdOk>> {
        if (requestParameters.stargateId === null || requestParameters.stargateId === undefined) {
            throw new runtime.RequiredError('stargateId','Required parameter requestParameters.stargateId was null or undefined when calling getUniverseStargatesStargateId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/stargates/{stargate_id}/`.replace(`{${"stargate_id"}}`, encodeURIComponent(String(requestParameters.stargateId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseStargatesStargateIdOkFromJSON(jsonValue));
    }

    /**
     * Get information on a stargate  --- Alternate route: `/dev/universe/stargates/{stargate_id}/`  Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
     * Get stargate information
     */
    async getUniverseStargatesStargateId(requestParameters: GetUniverseStargatesStargateIdRequest): Promise<GetUniverseStargatesStargateIdOk> {
        const response = await this.getUniverseStargatesStargateIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information on a star  --- Alternate route: `/dev/universe/stars/{star_id}/`  Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
     * Get star information
     */
    async getUniverseStarsStarIdRaw(requestParameters: GetUniverseStarsStarIdRequest): Promise<runtime.ApiResponse<GetUniverseStarsStarIdOk>> {
        if (requestParameters.starId === null || requestParameters.starId === undefined) {
            throw new runtime.RequiredError('starId','Required parameter requestParameters.starId was null or undefined when calling getUniverseStarsStarId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/stars/{star_id}/`.replace(`{${"star_id"}}`, encodeURIComponent(String(requestParameters.starId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseStarsStarIdOkFromJSON(jsonValue));
    }

    /**
     * Get information on a star  --- Alternate route: `/dev/universe/stars/{star_id}/`  Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
     * Get star information
     */
    async getUniverseStarsStarId(requestParameters: GetUniverseStarsStarIdRequest): Promise<GetUniverseStarsStarIdOk> {
        const response = await this.getUniverseStarsStarIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
     * Get station information
     */
    async getUniverseStationsStationIdRaw(requestParameters: GetUniverseStationsStationIdRequest): Promise<runtime.ApiResponse<GetUniverseStationsStationIdOk>> {
        if (requestParameters.stationId === null || requestParameters.stationId === undefined) {
            throw new runtime.RequiredError('stationId','Required parameter requestParameters.stationId was null or undefined when calling getUniverseStationsStationId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/stations/{station_id}/`.replace(`{${"station_id"}}`, encodeURIComponent(String(requestParameters.stationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseStationsStationIdOkFromJSON(jsonValue));
    }

    /**
     * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
     * Get station information
     */
    async getUniverseStationsStationId(requestParameters: GetUniverseStationsStationIdRequest): Promise<GetUniverseStationsStationIdOk> {
        const response = await this.getUniverseStationsStationIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
     * List all public structures
     */
    async getUniverseStructuresRaw(requestParameters: GetUniverseStructuresRequest): Promise<runtime.ApiResponse<Array<number>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/structures/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
     * List all public structures
     */
    async getUniverseStructures(requestParameters: GetUniverseStructuresRequest): Promise<Array<number>> {
        const response = await this.getUniverseStructuresRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/dev/universe/structures/{structure_id}/`  Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
     * Get structure information
     */
    async getUniverseStructuresStructureIdRaw(requestParameters: GetUniverseStructuresStructureIdRequest): Promise<runtime.ApiResponse<GetUniverseStructuresStructureIdOk>> {
        if (requestParameters.structureId === null || requestParameters.structureId === undefined) {
            throw new runtime.RequiredError('structureId','Required parameter requestParameters.structureId was null or undefined when calling getUniverseStructuresStructureId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.token !== undefined) {
            queryParameters['token'] = requestParameters.token;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("evesso", ["esi-universe.read_structures.v1"]);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/universe/structures/{structure_id}/`.replace(`{${"structure_id"}}`, encodeURIComponent(String(requestParameters.structureId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseStructuresStructureIdOkFromJSON(jsonValue));
    }

    /**
     * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/dev/universe/structures/{structure_id}/`  Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
     * Get structure information
     */
    async getUniverseStructuresStructureId(requestParameters: GetUniverseStructuresStructureIdRequest): Promise<GetUniverseStructuresStructureIdOk> {
        const response = await this.getUniverseStructuresStructureIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/dev/universe/system_jumps/`  Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
     * Get system jumps
     */
    async getUniverseSystemJumpsRaw(requestParameters: GetUniverseSystemJumpsRequest): Promise<runtime.ApiResponse<Array<GetUniverseSystemJumps200Ok>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/system_jumps/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GetUniverseSystemJumps200OkFromJSON));
    }

    /**
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/dev/universe/system_jumps/`  Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
     * Get system jumps
     */
    async getUniverseSystemJumps(requestParameters: GetUniverseSystemJumpsRequest): Promise<Array<GetUniverseSystemJumps200Ok>> {
        const response = await this.getUniverseSystemJumpsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/dev/universe/system_kills/`  Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
     * Get system kills
     */
    async getUniverseSystemKillsRaw(requestParameters: GetUniverseSystemKillsRequest): Promise<runtime.ApiResponse<Array<GetUniverseSystemKills200Ok>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/system_kills/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GetUniverseSystemKills200OkFromJSON));
    }

    /**
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/dev/universe/system_kills/`  Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
     * Get system kills
     */
    async getUniverseSystemKills(requestParameters: GetUniverseSystemKillsRequest): Promise<Array<GetUniverseSystemKills200Ok>> {
        const response = await this.getUniverseSystemKillsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
     * Get solar systems
     */
    async getUniverseSystemsRaw(requestParameters: GetUniverseSystemsRequest): Promise<runtime.ApiResponse<Array<number>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/systems/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
     * Get solar systems
     */
    async getUniverseSystems(requestParameters: GetUniverseSystemsRequest): Promise<Array<number>> {
        const response = await this.getUniverseSystemsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
     * Get solar system information
     */
    async getUniverseSystemsSystemIdRaw(requestParameters: GetUniverseSystemsSystemIdRequest): Promise<runtime.ApiResponse<GetUniverseSystemsSystemIdOk>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling getUniverseSystemsSystemId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/systems/{system_id}/`.replace(`{${"system_id"}}`, encodeURIComponent(String(requestParameters.systemId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseSystemsSystemIdOkFromJSON(jsonValue));
    }

    /**
     * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
     * Get solar system information
     */
    async getUniverseSystemsSystemId(requestParameters: GetUniverseSystemsSystemIdRequest): Promise<GetUniverseSystemsSystemIdOk> {
        const response = await this.getUniverseSystemsSystemIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a list of type ids  --- Alternate route: `/dev/universe/types/`  Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
     * Get types
     */
    async getUniverseTypesRaw(requestParameters: GetUniverseTypesRequest): Promise<runtime.ApiResponse<Array<number>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/types/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a list of type ids  --- Alternate route: `/dev/universe/types/`  Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
     * Get types
     */
    async getUniverseTypes(requestParameters: GetUniverseTypesRequest): Promise<Array<number>> {
        const response = await this.getUniverseTypesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
     * Get type information
     */
    async getUniverseTypesTypeIdRaw(requestParameters: GetUniverseTypesTypeIdRequest): Promise<runtime.ApiResponse<GetUniverseTypesTypeIdOk>> {
        if (requestParameters.typeId === null || requestParameters.typeId === undefined) {
            throw new runtime.RequiredError('typeId','Required parameter requestParameters.typeId was null or undefined when calling getUniverseTypesTypeId.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        const response = await this.request({
            path: `/universe/types/{type_id}/`.replace(`{${"type_id"}}`, encodeURIComponent(String(requestParameters.typeId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUniverseTypesTypeIdOkFromJSON(jsonValue));
    }

    /**
     * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
     * Get type information
     */
    async getUniverseTypesTypeId(requestParameters: GetUniverseTypesTypeIdRequest): Promise<GetUniverseTypesTypeIdOk> {
        const response = await this.getUniverseTypesTypeIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/` 
     * Bulk names to IDs
     */
    async postUniverseIdsRaw(requestParameters: PostUniverseIdsRequest): Promise<runtime.ApiResponse<PostUniverseIdsOk>> {
        if (requestParameters.names === null || requestParameters.names === undefined) {
            throw new runtime.RequiredError('names','Required parameter requestParameters.names was null or undefined when calling postUniverseIds.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        if (requestParameters.language !== undefined) {
            queryParameters['language'] = requestParameters.language;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        const response = await this.request({
            path: `/universe/ids/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.names,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PostUniverseIdsOkFromJSON(jsonValue));
    }

    /**
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/` 
     * Bulk names to IDs
     */
    async postUniverseIds(requestParameters: PostUniverseIdsRequest): Promise<PostUniverseIdsOk> {
        const response = await this.postUniverseIdsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Resolve a set of IDs to names and categories. Supported ID\'s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/v3/universe/names/` 
     * Get names and categories for a set of IDs
     */
    async postUniverseNamesRaw(requestParameters: PostUniverseNamesRequest): Promise<runtime.ApiResponse<Array<PostUniverseNames200Ok>>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError('ids','Required parameter requestParameters.ids was null or undefined when calling postUniverseNames.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.datasource !== undefined) {
            queryParameters['datasource'] = requestParameters.datasource;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/universe/names/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.ids,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PostUniverseNames200OkFromJSON));
    }

    /**
     * Resolve a set of IDs to names and categories. Supported ID\'s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/v3/universe/names/` 
     * Get names and categories for a set of IDs
     */
    async postUniverseNames(requestParameters: PostUniverseNamesRequest): Promise<Array<PostUniverseNames200Ok>> {
        const response = await this.postUniverseNamesRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetUniverseAncestriesAcceptLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseAncestriesDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseAncestriesLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseBloodlinesAcceptLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseBloodlinesDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseBloodlinesLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseCategoriesDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseCategoriesCategoryIdAcceptLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseCategoriesCategoryIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseCategoriesCategoryIdLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseConstellationsDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseConstellationsConstellationIdAcceptLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseConstellationsConstellationIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseConstellationsConstellationIdLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseFactionsAcceptLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseFactionsDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseFactionsLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseGraphicsDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseGraphicsGraphicIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseGroupsDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseGroupsGroupIdAcceptLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseGroupsGroupIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseGroupsGroupIdLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseMoonsMoonIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniversePlanetsPlanetIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseRacesAcceptLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseRacesDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseRacesLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseRegionsDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseRegionsRegionIdAcceptLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseRegionsRegionIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseRegionsRegionIdLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseStargatesStargateIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseStarsStarIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseStationsStationIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseStructuresDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseStructuresFilterEnum {
    Market = 'market',
    ManufacturingBasic = 'manufacturing_basic'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseStructuresStructureIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseSystemJumpsDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseSystemKillsDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseSystemsDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseSystemsSystemIdAcceptLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseSystemsSystemIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseSystemsSystemIdLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseTypesDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseTypesTypeIdAcceptLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseTypesTypeIdDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUniverseTypesTypeIdLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum PostUniverseIdsAcceptLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum PostUniverseIdsDatasourceEnum {
    Serenity = 'serenity'
}
/**
    * @export
    * @enum {string}
    */
export enum PostUniverseIdsLanguageEnum {
    EnUs = 'en-us',
    Zh = 'zh'
}
/**
    * @export
    * @enum {string}
    */
export enum PostUniverseNamesDatasourceEnum {
    Serenity = 'serenity'
}
